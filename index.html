<!DOCTYPE html>

<html lang="en">

<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	<title>game</title>
</head>

<body>

	<canvas id="gameCanvas" style="cursor: none;" width="800" height="600"></canvas>

	<script type = "text/javascript">
		
		//next 3 are defined in ballReset
		var ballX;
		var ballSpeedX;
		var ballY;
		var ballSpeedY = 4;
		var ballRadius = 5;
		
		var score = 0;
		var scoreMulti = 1;
		var lives = 3;
		
		const SCORE_BOARD_X = 1;
		const SCORE_BOARD_Y = 40;
		
		const BRICK_W = 20; //width
		const BRICK_H = 20; //height
		const BRICK_GAP = 2; //gap between bricks to make them distinquishable
		const BRICK_COLS = 40; // amount of brick columns
		const BRICK_ROWS = 14; //amount of brick rows
		
		var brickGrid = new Array(BRICK_COLS * BRICK_ROWS); 
		var bricksLeft = 0; //for reseting when all bricks are gone
		
		const PADDLE_WIDTH = 100;
		const PADDLE_THICKNESS = 10;
		const PADDLE_DIST_FROM_EDGE = 60; //distance between paddle and bottom of canvas
		var paddleX = 400;
		
		var canvas, canvasContext;
		
		var mouseX;
		var mouseY;
		
		var paddleCollisionCooldown = 0;
		
		
		
		//function to return mouse coordinates
		function updateMousePos(evt){
			var rect = canvas.getBoundingClientRect();//position of the canvas on page
			var root = document.documentElement;//position depending on scrolling of the page
			
			mouseX = evt.clientX - rect.left - root.scrollLeft;
			mouseY = evt.clientY - rect.top - root.scrollTop;
			
			paddleX = mouseX - PADDLE_WIDTH/2;
			
			//cheat to test ball in any position
			/*ballX = mouseX;
			ballY = mouseY;
			ballSpeedX = 1;
			ballSpeedY = -1;*/
			
		}
		
		//initial building of bricks and again after reset (player destroys them all or ball goes off bottom  of canvas)
		function brickReset(){
			brickGrid =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,
						0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
						0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
						0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,
						0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,
						0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,
						0,1,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			]
			bricksLeft = 0;
			/*var i;//declared outside so it can be used by both ifs
			for(i=0;i<5 * BRICK_COLS;i++){
				brickGrid[i] = 0;
			}//empty space on top
			for(;i<BRICK_COLS * BRICK_ROWS;i++){
					brickGrid[i] = 1;
					bricksLeft++;
			}//end of for each brick*/
		}//end of brickReset func
		
		function handleMouseClick(evt){
				if(lives == 0){
					score = 0;
					ballSpeedX = (0.5-Math.random())*6;
					var ballSpeedY = 4;
					ballX = canvas.width/2;
					ballY = canvas.height/2;
					lives = 3;
				}
			}
		
		//calling everything on window load
		window.onload = function(){
			canvas = document.getElementById('gameCanvas');
			canvasContext = canvas.getContext('2d')
			
			//refreshing page according to framerate
			var framesPerSecond = 60
			setInterval(updateAll, 1000/framesPerSecond);
			
			canvas.addEventListener('mousedown',handleMouseClick);
			
			//enables mouse coordinate tracking
			canvas.addEventListener('mousemove', updateMousePos);
			
			//initial setting
			brickReset();
			ballReset();
		}
		
		function updateAll(){
			moveAll();
			drawAll();
			
			//increase collision cd for later check
			paddleCollisionCooldown++
			//console.log(paddleCollisionCooldown)
		}
		
		//reset ball to the middle with randomized horizontal speed
		function ballReset(){
			ballX = canvas.width/2;
			ballY = canvas.height/2;
			ballSpeedX = (0.5-Math.random())*6;
		}
		
		//ball movement
		function ballMove(){
			ballX+=ballSpeedX
			ballY+=ballSpeedY
			
			//collision detection with borders, check for speed so ball doesn't get stuck in borders constastly reversing speeds (caused when there is a paddle hit at bottom corners)
			//speed check probably not necessary when taking ball radius into account, haven't tested
			if(ballX<ballRadius && ballSpeedX < 0.0){
				ballSpeedX *= -1;
			}
			
			if(ballX>canvas.width - ballRadius  && ballSpeedX > 0.0){
				ballSpeedX *= -1;
			}
			
			if(ballY<ballRadius + SCORE_BOARD_Y + 1 && ballSpeedY < 0.0){
				ballSpeedY *= -1;
			}
			
			if(ballY>canvas.height){
				ballReset();
				lives--;
				if(lives <= 0){
					brickReset();
				}
			}
		}
		
		//used to check if there is a brick at the location of the ball
		function isBrickAtColRow(col,row){
			if(col >=0 && 
			col < BRICK_COLS && 
			row >=0 && 
			row < BRICK_ROWS){
				var brickIndexUnderCoord = rowColToArrayIndex(col, row);
				return brickGrid[brickIndexUnderCoord];
			}else{
				return false;//used for collision at the bottom row of bricks (there are no bricks bellow them to check)
			}
		}
		
		//collision detection with bricks
		function BallBrickHandling(){
			var ballBrickCol = Math.floor(ballX / BRICK_W);//matches ball position with position in the array
			var ballBrickRow = Math.floor(ballY / BRICK_H);//matches ball position with position in the array
			var brickIndexUnderBall = rowColToArrayIndex(ballBrickCol, ballBrickRow);
			
			if(ballBrickCol >=0 && 
			ballBrickCol < BRICK_COLS && 
			ballBrickRow >=0 && 
			ballBrickRow < BRICK_ROWS){
				if(isBrickAtColRow(ballBrickCol,ballBrickRow)){
					
					brickGrid[brickIndexUnderBall] = 0; //removes the brick
					bricksLeft--;
					score += 10 * scoreMulti;
					//console.log(bricksLeft);
					
					//next 4 variables used to calculate the previous position of the ball to bounce the ball at the correct angle
					var prevBallX = ballX - ballSpeedX;
					var prevBallY = ballY - ballSpeedY;
					var prevBrickCol = Math.floor(prevBallX / BRICK_W);
					var prevBrickRow = Math.floor(prevBallY / BRICK_H);
					
					var bothTestsFailed = true;
					if(prevBrickCol != ballBrickCol){//the ball came from a different column
						
						if(isBrickAtColRow(prevBrickCol, ballBrickRow) == 0){//prevents reflections at corners of bricks that have an adjacent brick "alive" 
							ballSpeedX *= -1;
							bothTestsFailed = false;
						}
					}
					
					if(prevBrickRow != ballBrickRow){//the ball came from a different row
						
						if(isBrickAtColRow(ballBrickCol, prevBrickRow) == false){//prevents reflections at corners of bricks that have an adjacent brick "alive" 
							ballSpeedY *= -1;
							bothTestsFailed = false;
						}
					}
					
					if(bothTestsFailed){ //armpit case, prevents ball from going right through
						ballSpeedX *= -1;
						ballSpeedY *= -1;
					}
					
				}//end of brick found
			}//end of valid col and row
		}//end of ballBrickHandling func
		
		//collision detection with paddle
		function ballPaddleHandling(){
			//variables used for collision detection between ball-paddle
			var paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE;
			var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;
			var paddleLeftEdgeX = paddleX;
			var paddleRightEdgeX = paddleLeftEdgeX + PADDLE_WIDTH;
			
			//colision detection with paddle
			if( ballY > paddleTopEdgeY - ballRadius && 
				ballY < paddleBottomEdgeY + ballRadius/2 && 
				ballX > paddleLeftEdgeX - ballRadius && 
				ballX < paddleRightEdgeX + ballRadius){
				
				if(paddleCollisionCooldown >20){//prevents multiple collisions with paddle for a short time after a collision
					paddleCollisionCooldown = 0;
				
					ballSpeedY *= -1;
					
					var centerOfPaddleX = paddleX + PADDLE_WIDTH/2;
					var ballDistFromPaddleCenterX = ballX - centerOfPaddleX;
					ballSpeedX = ballDistFromPaddleCenterX * 0.15//different vertical speed after collision with paddle according to point of impact (for player control of direction)
				}
				
				if (bricksLeft == 0){ //you win, i guess
					brickReset();
					scoreMulti++;
				}//out of bricks
			}//ball center inside paddle
		}// end of ballPaddleHandling func
		
		//function that handles all movement
		function moveAll(){
			if(lives <= 0){
				return;
			}
			ballMove();
			BallBrickHandling();
			ballPaddleHandling();
		}
		
		//translates the position on the grid (2d) to the position in the array (1d)
		function rowColToArrayIndex(col, row){
			return col + BRICK_COLS * row;
		}
		
		function drawBricks(){
			for(eachRow=0;eachRow<BRICK_ROWS;eachRow++){
				for(eachCol=0;eachCol<BRICK_COLS;eachCol++){
				
					var arrayIndex = rowColToArrayIndex(eachCol, eachRow);
					
					if(brickGrid[arrayIndex]) {
						colorRect(BRICK_W*eachCol,BRICK_H*eachRow, BRICK_W - BRICK_GAP,BRICK_H - BRICK_GAP, 'blue');
					}//end of is this brick here
				}//end of for each brick
			}//end of for each row
		}//end of drawBricks func
		
		
		//function that handles drawing
		function drawAll(){	
			
			colorRect(0,0, canvas.width,canvas.height, 'black');//clear screen
			
			if(lives <= 0){
				canvasContext.fillStyle = 'white';
				canvasContext.fillText("Your Score: " + score,368,150);
				canvasContext.fillText("Click to Continue",363,450);
				return;
			}
			
			colorRect(SCORE_BOARD_X,SCORE_BOARD_Y, canvas.width - 2 * SCORE_BOARD_X,1, 'yellow');//scoreboard separator
			
			colorCircle(ballX,ballY, ballRadius, 'white');//draw ball
			
			colorRect(paddleX,canvas.height-PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH,PADDLE_THICKNESS, 'white');//paddle
			
			drawBricks();//bricks
			
			colorText("Lives remaining: " + lives, 685,23, 'red');
			
			colorText("Score: " + score, 30,23, 'red');
			
			//colorText(mouseBrickCol+","+mouseBrickRow+": "+brickIndexUnderMouse, mouseX,mouseY, 'yellow')
		}
		
		function colorRect(topLeftX,topLeftY,boxWidth, boxHeight,fillColor){
			canvasContext.fillStyle = fillColor;
			canvasContext.fillRect(topLeftX,topLeftY, boxWidth,boxHeight,fillColor);
		}
		
		function colorCircle(centerX,centerY, radius, fillColor){
			canvasContext.fillStyle = fillColor;
			canvasContext.beginPath();
			canvasContext.arc(centerX,centerY, radius, 0,Math.PI*2, true)
			canvasContext.fill();
		}
		
		function colorText(showWords, textX,textY, fillColor){
			canvasContext.fillStyle = fillColor;
			canvasContext.fillText(showWords, textX,textY);
		}
			
	</script>
	
</body>
	
</html>